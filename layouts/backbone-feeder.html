<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>馈线主干示例 | GoJS 布局画廊</title>
    <script src="https://unpkg.com/gojs/release/go.js"></script>
    <style>
      :root {
        color-scheme: light;
      }

      body {
        margin: 0;
        font-family: "Microsoft YaHei", "PingFang SC", "Segoe UI", sans-serif;
        background: #f1f5f9;
        color: #1f2937;
        min-height: 100vh;
      }

      header {
        padding: 18px 24px 10px;
      }

      header h1 {
        margin: 0;
        font-size: clamp(22px, 3vw, 32px);
        font-weight: 600;
        color: #0f172a;
      }

      header p {
        margin: 8px 0 0;
        max-width: 900px;
        line-height: 1.6;
        color: #4b5563;
      }

      main {
        max-width: 1440px;
        margin: 0 auto;
        padding: 0 24px 48px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
        font-size: 14px;
        color: #475569;
      }

      .back-link {
        color: #2563eb;
        text-decoration: none;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .back-link::before {
        content: "←";
        font-size: 16px;
      }

      #diagramDiv {
        width: 100%;
        height: 720px;
        background: #ffffff;
        border: 1px solid #d7dce3;
        border-radius: 8px;
        box-shadow: 0 14px 32px rgba(15, 23, 42, 0.08);
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
        font-size: 13px;
        color: #475569;
        background: #fff;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        padding: 14px 18px;
        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.06);
      }

      .legend strong {
        color: #0f172a;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>馈线主干纵向展开示例</h1>
      <p>
        模拟 35kV 馈线的主干走向，并在干线节点上下布置分支台区、联络和重要负荷，强调“中间主干 + 上下分支”的配网巡检视图布局。
      </p>
    </header>
    <main>
      <div class="toolbar">
        <a class="back-link" href="../index.html">返回布局画廊</a>
        <span id="stats">节点数：0 · 连接数：0</span>
      </div>
      <div id="diagramDiv" role="presentation" aria-label="馈线主干示例"></div>
      <div class="legend">
        <div><strong>主干节点</strong>：双环符号沿主线排布，连接处为馈线主干开关。</div>
        <div><strong>上下支路</strong>：side=top/bottom 控制分支向上或向下延伸，保持纵向对齐。</div>
        <div><strong>状态指示</strong>：红色圆点用于高亮告警节点，其余节点仅显示符号。</div>
      </div>
    </main>
    <script>
      window.addEventListener("DOMContentLoaded", () => {
        const $ = go.GraphObject.make;

        const layoutConfig = {
          backboneSpacing: 180,
          branchSpacing: 90,
          levelSpacing: 110,
          centerY: 0,
        };

        const applyBackboneLayout = (diagram) => {
          if (!diagram) return;
          diagram.startTransaction("Backbone Layout");

          const backboneNodes = [];
          diagram.nodes.each((node) => {
            if (node instanceof go.Node && node.data && node.data.backbone) {
              backboneNodes.push(node);
            }
          });

          if (backboneNodes.length === 0) {
            diagram.commitTransaction("Backbone Layout");
            return;
          }

          backboneNodes.sort((a, b) => {
            const ao = typeof a.data.order === "number" ? a.data.order : 0;
            const bo = typeof b.data.order === "number" ? b.data.order : 0;
            return ao - bo;
          });

          const baseY = layoutConfig.centerY;
          const startX = -((backboneNodes.length - 1) * layoutConfig.backboneSpacing) / 2;
          backboneNodes.forEach((node, index) => {
            const point = new go.Point(startX + index * layoutConfig.backboneSpacing, baseY);
            node.move(point);
          });

          const childrenMap = new Map();
          diagram.model.nodeDataArray.forEach((data) => {
            if (!data.parent) return;
            if (data.backbone) return;
            if (!childrenMap.has(data.parent)) childrenMap.set(data.parent, []);
            childrenMap.get(data.parent).push(data);
          });

          const memo = new Map();
          const unitCount = (key, orientation) => {
            const memoKey = `${orientation}:${key}`;
            if (memo.has(memoKey)) return memo.get(memoKey);
            const children = (childrenMap.get(key) || []).filter(
              (child) => (child.side || "bottom") === orientation
            );
            if (children.length === 0) {
              memo.set(memoKey, 1);
              return 1;
            }
            let total = 0;
            children.forEach((child) => {
              total += unitCount(child.key, orientation);
            });
            total = Math.max(total, 1);
            memo.set(memoKey, total);
            return total;
          };

          const layoutBranchSet = (parentNode, orientation) => {
            if (!(parentNode instanceof go.Node)) return;
            const parentData = parentNode.data;
            if (!parentData || !parentData.key) return;

            const children = (childrenMap.get(parentData.key) || []).filter(
              (child) => (child.side || "bottom") === orientation
            );
            if (children.length === 0) return;

            const base = parentNode.position;
            const offsetY = orientation === "top" ? -layoutConfig.levelSpacing : layoutConfig.levelSpacing;
            const childY = base.y + offsetY;
            const totalUnits = children.reduce(
              (sum, child) => sum + unitCount(child.key, orientation),
              0
            );
            const unitSpacing = layoutConfig.branchSpacing;
            const startX = base.x - ((totalUnits - 1) * unitSpacing) / 2;

            let cursor = startX;
            children.forEach((childData, index) => {
              const units = unitCount(childData.key, orientation);
              let childCenterX = cursor + ((units - 1) * unitSpacing) / 2;

              if (children.length === 1) {
                childCenterX = base.x;
              } else if (children.length === 2 && totalUnits === units) {
                childCenterX = index === 0 ? base.x - unitSpacing / 2 : base.x + unitSpacing / 2;
              }

              const childNode = diagram.findNodeForData(childData);
              if (childNode instanceof go.Node) {
                childNode.move(new go.Point(childCenterX, childY));
                layoutBranchSet(childNode, orientation);
              }
              cursor += units * unitSpacing;
            });
          };

          backboneNodes.forEach((node) => {
            layoutBranchSet(node, "top");
            layoutBranchSet(node, "bottom");
          });

          diagram.commitTransaction("Backbone Layout");
        };

        const labelSideFor = (data) => {
          if (!data) return "bottom";
          if (data.labelSide) return data.labelSide;
          if (data.side === "top") return "top";
          if (data.side === "bottom") return "bottom";
          return "bottom";
        };

        const diagram = $(go.Diagram, "diagramDiv", {
          layout: $(go.Layout, { isInitial: false, isOngoing: false }),
          initialAutoScale: go.Diagram.Uniform,
          padding: new go.Margin(60, 80, 60, 80),
          "undoManager.isEnabled": false,
        });

        if (diagram.div) {
          diagram.div.style.background = "#ffffff";
        }

        diagram.nodeTemplate = $(
          go.Node,
          "Spot",
          {
            selectionAdorned: false,
            locationSpot: go.Spot.Center,
          },
          new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
          $(
            go.Panel,
            "Spot",
            { name: "SYMBOL", width: 30, height: 30 },
            $(
              go.Shape,
              "Circle",
              {
                width: 26,
                height: 26,
                fill: "white",
                stroke: "#0f172a",
                strokeWidth: 1.6,
                portId: "",
                fromLinkable: true,
                toLinkable: true,
              },
              new go.Binding("stroke", "backbone", (isBackbone) =>
                isBackbone ? "#0f172a" : "#1f2937"
              ),
              new go.Binding("strokeWidth", "thick", (thick) => (thick ? 2.2 : 1.6)),
              new go.Binding("fromSpot", "", (data) => {
                if (!data) return go.Spot.AllSides;
                if (data.side === "top") return go.Spot.Top;
                if (data.side === "bottom") return go.Spot.Bottom;
                return go.Spot.AllSides;
              }),
              new go.Binding("toSpot", "", (data) => {
                if (!data) return go.Spot.AllSides;
                if (data.side === "top") return go.Spot.Bottom;
                if (data.side === "bottom") return go.Spot.Top;
                return go.Spot.AllSides;
              })
            ),
            $(
              go.Shape,
              "Circle",
              {
                width: 18,
                height: 18,
                stroke: "#0f172a",
                strokeWidth: 1.1,
                fill: "transparent",
                visible: false,
              },
              new go.Binding("visible", "", (data) => !!(data && (data.doubleRing || data.backbone)))
            ),
            $(go.Shape, "LineV", {
              stroke: "#0f172a",
              strokeWidth: 1.2,
              height: 18,
              visible: false,
            }, new go.Binding("visible", "backbone")),
            $(
              go.Shape,
              "Circle",
              {
                width: 8,
                height: 8,
                strokeWidth: 0,
                alignment: new go.Spot(0.5, 1, 0, 14),
                visible: false,
              },
              new go.Binding("visible", "", (data) => {
                if (!data) return false;
                if (data.indicator) return true;
                return data.status === "warning" || data.status === "outage" || data.status === "maintenance";
              }),
              new go.Binding("figure", "indicator", (indicator) =>
                indicator && indicator.figure ? indicator.figure : "Circle"
              ),
              new go.Binding("fill", "", (data) => {
                if (data.indicator && data.indicator.color) return data.indicator.color;
                if (data.status === "warning") return "#f97316";
                if (data.status === "outage") return "#ef4444";
                if (data.status === "maintenance") return "#2563eb";
                return "#22c55e";
              })
            )
          ),
          $(
            go.Panel,
            "Vertical",
            {
              name: "LABEL",
              alignment: go.Spot.Bottom,
              alignmentFocus: go.Spot.Top,
            },
            new go.Binding("alignment", "", (data) => {
              const side = labelSideFor(data);
              switch (side) {
                case "top":
                  return new go.Spot(0.5, 0, 0, -24);
                case "left":
                  return new go.Spot(0, 0.5, -24, 0);
                case "right":
                  return new go.Spot(1, 0.5, 24, 0);
                default:
                  return new go.Spot(0.5, 1, 0, 24);
              }
            }),
            new go.Binding("alignmentFocus", "", (data) => {
              const side = labelSideFor(data);
              switch (side) {
                case "top":
                  return go.Spot.Bottom;
                case "left":
                  return go.Spot.Right;
                case "right":
                  return go.Spot.Left;
                default:
                  return go.Spot.Top;
              }
            }),
            $(
              go.TextBlock,
              {
                font: "12px 'Microsoft YaHei'",
                stroke: "#0f172a",
                maxSize: new go.Size(160, NaN),
                wrap: go.Wrap.Fit,
                textAlign: "center",
                visible: false,
              },
              new go.Binding("visible", "name", (name) => !!name),
              new go.Binding("text", "name")
            )
          )
        );

        diagram.linkTemplate = $(
          go.Link,
          {
            routing: go.Link.Orthogonal,
            corner: 0,
            selectable: false,
            fromEndSegmentLength: 18,
            toEndSegmentLength: 18,
            layerName: "Background",
          },
          $(go.Shape, {
            stroke: "#111827",
            strokeWidth: 1.6,
          })
        );

        const backboneNodes = [
          { key: "B0", name: "联络开关", backbone: true, order: 0, doubleRing: true, status: "warning" },
          { key: "B1", name: "#1 断路器", backbone: true, order: 1, doubleRing: true },
          { key: "B2", name: "环网柜 A", backbone: true, order: 2, doubleRing: true, status: "maintenance" },
          { key: "B3", name: "柱上开关", backbone: true, order: 3, doubleRing: true },
          { key: "B4", name: "环网柜 B", backbone: true, order: 4, doubleRing: true, status: "warning" },
          { key: "B5", name: "分段开关", backbone: true, order: 5, doubleRing: true },
          { key: "B6", name: "末端联络", backbone: true, order: 6, doubleRing: true },
        ];

        const branchData = [
          { key: "T0", parent: "B1", side: "top", name: "城北联络柜", doubleRing: true, status: "warning" },
          { key: "T0-1", parent: "T0", side: "top", name: "联络负荷" },
          { key: "T1", parent: "B2", side: "top", name: "环网联络", doubleRing: true, status: "maintenance" },
          { key: "T1-1", parent: "T1", side: "top", name: "备用馈线" },
          { key: "T2", parent: "B4", side: "top", name: "工业园联络", doubleRing: true, status: "warning" },
          { key: "T2-1", parent: "T2", side: "top", name: "重点监测", indicator: { color: "#ef4444", figure: "Rectangle" } },
          { key: "T2-2", parent: "T2", side: "top", name: "远供线路" },

          { key: "D0", parent: "B1", side: "bottom", name: "台区 1" },
          { key: "D0-1", parent: "D0", side: "bottom", name: "配变 1" },
          { key: "D0-2", parent: "D0", side: "bottom", name: "台区支线" },

          { key: "D1", parent: "B2", side: "bottom", name: "商业台区", status: "warning" },
          { key: "D1-1", parent: "D1", side: "bottom", name: "配变 2", indicator: { color: "#f97316", figure: "Rectangle" } },
          { key: "D1-2", parent: "D1", side: "bottom", name: "重要用户" },

          { key: "D2", parent: "B3", side: "bottom", name: "农村台区" },
          { key: "D2-1", parent: "D2", side: "bottom", name: "分支 A", status: "maintenance" },
          { key: "D2-2", parent: "D2", side: "bottom", name: "分支 B" },

          { key: "D3", parent: "B4", side: "bottom", name: "工业台区", status: "warning" },
          { key: "D3-1", parent: "D3", side: "bottom", name: "配变 3", indicator: { color: "#f97316", figure: "Rectangle" } },
          { key: "D3-2", parent: "D3", side: "bottom", name: "分支车间" },

          { key: "D4", parent: "B5", side: "bottom", name: "学校台区" },
          { key: "D4-1", parent: "D4", side: "bottom", name: "教学配变" },
          { key: "D4-2", parent: "D4", side: "bottom", name: "宿舍支线" },

          { key: "D5", parent: "B6", side: "bottom", name: "终端台区" },
          { key: "D5-1", parent: "D5", side: "bottom", name: "终端配变" },
          { key: "D5-2", parent: "D5", side: "bottom", name: "应急电源" },
        ];

        const nodeDataArray = backboneNodes.concat(branchData);

        diagram.model = new go.TreeModel(nodeDataArray);
        applyBackboneLayout(diagram);

        const stats = document.getElementById("stats");
        if (stats) {
          const totalNodes = diagram.model.nodeDataArray.length;
          const totalLinks = totalNodes - 1;
          stats.textContent = `节点数：${totalNodes} · 连接数：${totalLinks}`;
        }
      });
    </script>
  </body>
</html>
